"""Portfolio and position tracking utilities.

This module focuses on cash accounting, cost basis tracking and
performance attribution for a simple long-only equity portfolio.
"""
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Iterable, Mapping, Optional


@dataclass
class Position:
    """Represents holdings for a single symbol.

    The position tracks the total number of shares held and their
    aggregate cost basis (the total amount spent acquiring the shares).
    """

    symbol: str
    shares: float = 0.0
    cost_basis: float = 0.0

    def add(self, shares: float, price: float) -> None:
        """Increase holdings for the position.

        Args:
            shares: Number of shares to add. Must be positive.
            price: Execution price for the trade. Must be positive.
        """

        if shares <= 0:
            raise ValueError("Shares to add must be positive")
        if price <= 0:
            raise ValueError("Price must be positive")

        self.shares += shares
        self.cost_basis += price * shares

    def remove(self, shares: float, price: float) -> float:
        """Reduce holdings and return the realised P&L for the trade.

        The realised profit is computed using the current average cost.
        Historically the method removed cost basis using the execution
        price which caused the remaining cost basis to drift whenever the
        sale price differed from the acquisition cost. That resulted in
        inflated unrealised P&L for the leftover position. The corrected
        implementation removes the cost basis using the average purchase
        cost prior to the sale so that accounting remains self-consistent.

        Args:
            shares: Number of shares to sell. Must be positive and less
                than or equal to the number of shares currently held.
            price: Execution price for the sale. Must be positive.

        Returns:
            The realised P&L generated by the sale.
        """

        if shares <= 0:
            raise ValueError("Shares to remove must be positive")
        if price <= 0:
            raise ValueError("Price must be positive")
        if shares > self.shares:
            raise ValueError("Cannot sell more shares than currently held")

        if self.shares == 0:
            return 0.0

        average_cost = self.cost_basis / self.shares
        realised_pnl = (price - average_cost) * shares

        self.cost_basis -= average_cost * shares
        self.shares -= shares

        if self.shares <= 1e-12:
            # Guard against floating point residue.
            self.shares = 0.0
            self.cost_basis = 0.0
        elif abs(self.cost_basis) <= 1e-9:
            self.cost_basis = 0.0

        return realised_pnl

    @property
    def average_cost(self) -> float:
        """Average purchase price for the remaining shares."""

        if self.shares == 0:
            return 0.0
        return self.cost_basis / self.shares

    def market_value(self, price: float) -> float:
        """Return the market value of the position at ``price``."""

        if price < 0:
            raise ValueError("Price must be non-negative")
        return self.shares * price


class Portfolio:
    """Tracks cash, positions and realised/unrealised P&L."""

    def __init__(self, cash: float = 0.0):
        self.cash = float(cash)
        self._positions: Dict[str, Position] = {}
        self._realised_pnl = 0.0

    @property
    def realised_pnl(self) -> float:
        """Aggregate realised P&L across all closed trades."""

        return self._realised_pnl

    def position(self, symbol: str) -> Optional[Position]:
        """Return the :class:`Position` for ``symbol`` if present."""

        return self._positions.get(symbol)

    def positions(self) -> Iterable[Position]:
        """Iterate over all positions in the portfolio."""

        return self._positions.values()

    def buy(self, symbol: str, price: float, shares: float) -> None:
        """Execute a purchase and update cash and cost basis."""

        if shares <= 0:
            raise ValueError("Shares to buy must be positive")
        if price <= 0:
            raise ValueError("Price must be positive")

        total_cost = price * shares
        self.cash -= total_cost

        position = self._positions.get(symbol)
        if position is None:
            position = Position(symbol=symbol)
            self._positions[symbol] = position

        position.add(shares, price)

    def sell(self, symbol: str, price: float, shares: float) -> float:
        """Execute a sale and update cash, positions and realised P&L."""

        position = self._positions.get(symbol)
        if position is None:
            raise KeyError(f"No position for symbol '{symbol}'")

        realised_pnl = position.remove(shares, price)
        self.cash += price * shares
        self._realised_pnl += realised_pnl

        if position.shares == 0:
            del self._positions[symbol]

        return realised_pnl

    def market_value(self, prices: Mapping[str, float]) -> float:
        """Return the total market value including cash."""

        total = self.cash
        for symbol, position in self._positions.items():
            try:
                price = prices[symbol]
            except KeyError as exc:  # pragma: no cover - defensive.
                raise KeyError(f"Missing price for symbol '{symbol}'") from exc
            total += position.market_value(price)
        return total

    def unrealised_pnl(self, prices: Mapping[str, float]) -> float:
        """Return the sum of unrealised P&L for open positions."""

        pnl = 0.0
        for symbol, position in self._positions.items():
            try:
                price = prices[symbol]
            except KeyError as exc:  # pragma: no cover - defensive.
                raise KeyError(f"Missing price for symbol '{symbol}'") from exc
            pnl += (price - position.average_cost) * position.shares
        return pnl

    def snapshot(self, prices: Mapping[str, float]) -> Dict[str, float]:
        """Provide a summary of portfolio state.

        Returns a dictionary containing cash, market value and P&L figures.
        """

        market_value = self.market_value(prices)
        unrealised = self.unrealised_pnl(prices)
        return {
            "cash": self.cash,
            "market_value": market_value,
            "realised_pnl": self._realised_pnl,
            "unrealised_pnl": unrealised,
            "total_equity": market_value,
        }
